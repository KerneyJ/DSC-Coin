#include <cstddef>
#include <cstdint>
#include <iostream>
#include <string>
#include <array>
#include <iomanip> 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <vector>

#include "defs.hpp"
#include "transaction.hpp"
#include "wallet.hpp"
#include "keys.hpp"

// // Overload << for Ed25519Key
// std::ostream& operator<<(std::ostream& os, const Ed25519Key& hash) {
//     for (auto byte : hash) {
//         os << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
//     }
//     return os;
// }
// Overload >> for Ed25519Key
std::istream& operator>>(std::istream& is, Ed25519Key& hash) {
    // Assuming the input is in hexadecimal format
    for (auto& byte : hash) {
        int tmp;
        if (is >> std::hex >> tmp) {
            byte = static_cast<unsigned char>(tmp);
        } else {
            is.setstate(std::ios_base::failbit);
            return is;
        }
    }
    return is;
}

static uint64_t nonce = 0;

static uint64_t get_nonce() {
    return nonce++;
}

Wallet create_wallet() {
    Ed25519Key pub_key, priv_key;
    gen_keys_ed25519(pub_key, priv_key);
    
    return { priv_key, pub_key };
}

// load wallet from file
Wallet load_wallet(std::string filepath) {
    return {};
}

// write wallet to file
void store_wallet(std::string filepath, Wallet wallet) {

}

void sign_transaction(Ed25519Key priv_key, Transaction &tx) {
    tx.signature.fill(0);
    tx.signature = sign_data_ed25519(priv_key, (uint8_t*) &tx, sizeof(Transaction));
}

bool verify_transaction_signature(Ed25519Key pub_key, Transaction tx) {
    Ed25519Signature signature = tx.signature;
    tx.signature.fill(0);
    return verify_signature_ed25519(pub_key, signature, (uint8_t*) &tx, sizeof(Transaction));
}

// signature is generated in create_transaction, it should sign all of the other fields in the transaction struct
// the id of the transaction should be unique for each transaction generated by a wallet 
Transaction create_transaction(Wallet wallet, Ed25519Key dest, uint32_t amount) {
    Transaction tx;

    tx.src = wallet.pub_key;
    tx.dest = dest;
    tx.amount = amount;
    tx.id = get_nonce();
    tx.timestamp = static_cast<uint64_t>(std::time(nullptr));
    
    sign_transaction(wallet.priv_key, tx);

    return tx;
}

// Function to display wallet information
void display_wallet(const Wallet& wallet) {
    // Display the wallet information
    std::cout << "Public Key: ";
    for (auto byte : wallet.pub_key) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    std::cout << std::endl;

    // Display the private key (for demonstration purposes)
    std::cout << "Private Key: ";
    for (auto byte : wallet.priv_key) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    std::cout << std::endl;
}

int main(int argc, char** argv) {
    struct Wallet wallet;

    while (true) {
        std::cout << "\n\n---------------------------------\n\n";
        std::cout << "\n\nWelcome to da crypto wallet 💰💰💰\n\n";
        std::cout << "What would you like to do?\n";
        std::cout << "Quit                  [0]\n";
        std::cout << "create wallet         [1]\n";
        std::cout << "load wallet           [2]\n";
        std::cout << "Display wallet        [3]\n";
        std::cout << "create transaction    [4]\n";
        std::cout << "Query balance         [5]\n";
        std::cout << "Your selection:        ";
        
        int menu_selection;
        std::cin >> menu_selection;
        
        switch (menu_selection) {
            case 0: {
                std::cout << "Goodbye! ✌️\n";
                return 0;
            }

            case 1: {
                Wallet wallet = create_wallet();
                std::cout << "\nWallet created successfully!\n";
                display_wallet(wallet);
                break;
            }

            case 2: {
                // TODO
                std::cout << "`load_wallet` not implemented.";
                // std::cout << "Please enter the filepath to your wallet: ";
                break;
            }

            case 3: {
                std::cout << "Displaying your wallet...";
                display_wallet(wallet); 
                break;
            }

            case 4: {
                Ed25519Key dest;
                uint32_t amount;
                std::cout << "Creating transaction...\n";
                // std::cout <<"enter address of payment recipient: ";
                // std::cin >> dest;
                // std::cout <<"Enter the amount to be paid: ";
                // std::cin >> amount;

                // TODO: take input
                amount = 69;
                dest.fill(2);

                Wallet wallet = create_wallet();
                Transaction tx = create_transaction(wallet, dest, amount);

                printf("src address (%lu bytes):\n", tx.src.size());
                for(int i = 0; i < tx.src.size(); i++)
                    printf("%02x", tx.src[i]);
                printf("\n");
                
                printf("dest address (%lu bytes):\n", tx.dest.size());
                for(int i = 0; i < tx.dest.size(); i++)
                    printf("%02x", tx.dest[i]);
                printf("\n");
                
                printf("signature (%lu bytes):\n", tx.signature.size());
                for(int i = 0; i < tx.signature.size(); i++)
                    printf("%02x", tx.signature[i]);
                printf("\n");
                
                printf("amount: %d\n", tx.amount);
                printf("id: %lu\n", tx.id);
                printf("timestamp: %lu\n", tx.timestamp);

                break;
            }

            case 5: {
                std::cout << "query_balance() not implemented";
                // int balance = query_balance();
                // std::cout << "Your balance is: " << balance << std::endl;
                break;
            }
            

            default: {
                std::cout << "Invalid choice. Please try again \n";
            }
        }
    }

    return 0;
}